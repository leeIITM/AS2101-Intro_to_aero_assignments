# -*- coding: utf-8 -*-
"""SVM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pxDhfowmcVnr5B6biikpTr6JDWM3JqTQ
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score
file_path = input()
'''file_path = "/content/drive/MyDrive/Data (1).txt"'''
data = np.loadtxt(file_path)

# Spliting the data into features (X) and labels (y)
X = data[:, :-1]
y = data[:, -1]

# Standardizing the features
scaler = StandardScaler()
X = scaler.fit_transform(X)

# Split into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Function to plot 3D/2D SVM decision boundary and classified points
def plot_3d_with_hyperplane(X, y, model, title, file_name):
    fig = plt.figure()

    # Check if the data has 3 dimensions, if not, create a 2D plot
    if X.shape[1] == 3:
        ax = fig.add_subplot(111, projection='3d')

        # Classifying points as red and blue
        colors = ['red' if label == 1 else 'blue' for label in y]
        ax.scatter(X[:, 0], X[:, 1], X[:, 2], c=colors, s=50, alpha=0.6)

        # Creating a mesh grid to plot decision boundary in 3D
        xlim = (X[:, 0].min(), X[:, 0].max())
        ylim = (X[:, 1].min(), X[:, 1].max())
        zlim = (X[:, 2].min(), X[:, 2].max())

        xx, yy = np.meshgrid(np.linspace(xlim[0], xlim[1], 30),
                             np.linspace(ylim[0], ylim[1], 30))

        # Using decision function to find the decision boundary
        zz = (-model.intercept_[0] - model.coef_[0][0] * xx - model.coef_[0][1] * yy) / model.coef_[0][2]

        # Ploting the decision boundary (hyperplane) with a green color
        ax.plot_surface(xx, yy, zz, color='green', alpha=0.3)

        ax.set_zlabel('Z Label')
    else:
        ax = fig.add_subplot(111)

        # Classify points as red and blue
        colors = ['red' if label == 1 else 'blue' for label in y]
        ax.scatter(X[:, 0], X[:, 1], c=colors, s=50, alpha=0.6)

        # Create a mesh grid to plot decision boundary in 2D
        xlim = (X[:, 0].min(), X[:, 0].max())
        ylim = (X[:, 1].min(), X[:, 1].max())

        xx, yy = np.meshgrid(np.linspace(xlim[0], xlim[1], 30),
                             np.linspace(ylim[0], ylim[1], 30))

        # Use decision function to find the decision boundary
        Z = model.decision_function(np.c_[xx.ravel(), yy.ravel()])
        Z = Z.reshape(xx.shape)

        # Plot the decision boundary (contour)
        ax.contour(xx, yy, Z, colors='k', levels=[-1, 0, 1], alpha=0.5, linestyles=['--', '-', '--'])

    ax.set_xlabel('X Label')
    ax.set_ylabel('Y Label')
    ax.set_title(title)

    # Save the plot
    plt.savefig(file_name)
    plt.show()

# Train and test various SVM models, plot results, and save graphs
svm_models = {
    'linear': SVC(kernel='linear'),
    'poly': SVC(kernel='poly', degree=3),
    'rbf': SVC(kernel='rbf'),
    'sigmoid': SVC(kernel='sigmoid'),
    'linear_with_C': SVC(kernel='linear', C=0.1)  # Example with different C value
}

for name, svm in svm_models.items():

    svm.fit(X_train, y_train)


    y_pred = svm.predict(X_test)

    accuracy = accuracy_score(y_test, y_pred)
    print(f"Accuracy for {name} SVM: {accuracy:.4f}")


    plot_3d_with_hyperplane(X_train, y_train, svm, f'{name.capitalize()} SVM (Train)', f'{name}_svm_train.png')


    plot_3d_with_hyperplane(X_test, y_test, svm, f'{name.capitalize()} SVM (Test)', f'{name}_svm_test.png')